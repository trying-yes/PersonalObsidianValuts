非常好的问题！这正是理解程序加载过程的关键。操作系统**并不是凭空猜测**分配多少内存的，它完全依赖于**可执行文件本身提供的信息**。

这个信息存储在可执行文件的**头部结构**中。我们以Linux上最常见的**ELF** 格式和Windows上的**PE** 格式为例来解释。

---

### 编译和链接阶段：写入“建筑图纸”

当你编译和链接一个程序时，链接器会生成一个结构化的可执行文件。这个文件不仅包含机器码，还包含一个**程序头表**，它就像一份详细的“建筑图纸”，明确告诉操作系统需要如何布置内存。

#### 以Linux ELF格式为例：

一个ELF可执行文件包含多个**段**，其中最重要的两个**可加载段**是：

1.  **`PT_LOAD`（代码段）**
    *   **内容**： 你的程序指令（`.text` 节）、以及只读数据（如字符串常量，在 `.rodata` 节）。
    *   **头部信息**：
        *   `p_vaddr`： 这个段应该被加载到虚拟内存中的哪个地址。
        *   `p_filesz`： 这个段在文件中有多大。
        *   `p_memsz`： 这个段在内存中需要占用多大。
        *   `p_flags`： 权限标志（`r-x`，即可读可执行，但不可写）。

2.  **`PT_LOAD`（数据段）**
    *   **内容**： 已初始化的全局/静态变量（`.data` 节）、以及未初始化的全局/静态变量（`.bss` 节）。
    *   **头部信息**：
        *   `p_vaddr`, `p_filesz`, `p_memsz`
        *   `p_flags`： 权限标志（`rw-`，即可读可写，但不可执行）。
        *   **关键点**： 对于 `.bss` 节（未初始化变量），它们在文件中不占空间（`p_filesz` 较小），但在内存中需要被分配空间并初始化为0（`p_memsz` 较大）。**操作系统就是通过 `p_memsz` 和 `p_filesz` 的差值，知道需要额外分配多少零页内存给 `.bss` 节的。**

---

### 加载阶段：操作系统“按图施工”

当你在shell中执行 `./program` 时，操作系统的**加载器**会：

1.  **解析头部**： 读取ELF文件的头部，找到所有 `PT_LOAD` 段。
2.  **计算总大小**：
    *   对于代码段，它需要分配 `p_memsz` 字节。
    *   对于数据段，它需要分配 `p_memsz` 字节。
    *   **这些大小是精确的、已知的，直接从文件头部读取。**
3.  **分配虚拟内存空间**：
    *   加载器通过 `mmap` 系统调用，请求内核在进程的虚拟地址空间中，在 `p_vaddr` 指定的位置，精确地映射 `p_memsz` 字节，并设置好 `p_flags` 指定的权限。
    *   内核只是批准这个虚拟地址范围的分配，此时可能还没有分配实际的物理内存（惰性分配，在第一次访问时才会触发缺页中断分配物理页）。

### 堆和栈的分配

现在我们来回答你的核心问题：堆和栈的大小是怎么知道的？

1.  **堆的初始大小**
    *   **操作系统不知道，也不需要知道堆的总大小。**
    *   加载器所做的，只是在数据段之后，设置一个称为**程序中断点** 的指针。堆就是从这一点开始向上生长的区域。
    *   初始时，堆的大小几乎是0。当程序第一次调用 `malloc` 请求内存时，如果堆上没有足够空间，`malloc` 的实现会通过 `brk()` 或 `sbrk()` 系统调用，请求操作系统将程序中断点**抬高**，从而为堆**增加**更多的虚拟内存空间。这是一个**动态增长**的过程。

2.  **栈的初始大小**
    *   栈的大小通常由一个**默认值**决定。在Linux上，这个默认值通常是 **8 MB**。
    *   这个信息可能来自：
        *   **操作系统内核的默认配置**。
        *   **可执行文件本身的备注节**（例如ELF的 `.note` 节）中可以建议栈大小，但最终决定权在加载器/内核。
        *   用户也可以通过 `ulimit -s` 命令来修改shell的默认栈大小。
    *   加载器会在进程虚拟地址空间的顶端直接保留这么大一块区域（例如8MB）给栈使用。

### 总结表格

| 内存区域 | 大小如何确定                                                   |
| :------- | :------------------------------------------------------------- |
| **代码段** | **精确已知**。由链接器计算并写入ELF头部的 `p_memsz` 字段。       |
| **数据段** | **精确已知**。由链接器计算并写入ELF头部的 `p_memsz` 字段。       |
| **堆**   | **初始为0，动态增长**。由 `malloc` 通过 `brk`/`mmap` 按需向操作系统申请。 |
| **栈**   | **使用默认大小**（如8MB）。由操作系统加载器设定，通常可配置。     |

**核心思想**：操作系统就像一个严格的施工队，它完全按照编译器/链接器提供的“蓝图”（即可执行文件格式）来构建进程的内存空间。对于蓝图里明确指出的部分（代码、数据），它精确分配；对于需要运行时动态决定的部分（堆），它提供增长机制；对于有惯例的部分（栈），它使用合理的默认值。